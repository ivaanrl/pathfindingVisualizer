{"version":3,"sources":["components/node/node.js","algorithms/helpers/getUnvisitedNeighbors.js","algorithms/weightedAlgorithms/dijkstra.js","algorithms/weightedAlgorithms/Astar.js","components/pathfindingVisualizer/PathfindingVisualizer.js","algorithms/unweightedAlgorithms/DFS.js","algorithms/unweightedAlgorithms/BFS.js","algorithms/helpers/getNodesInShortestPathOrder.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","setNodeVisited","string","state","isWall","isWeight","setState","nodeVisited","resetStyle","setShortestPath","setWall","setWeight","this","row","col","isEnd","isStart","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","draggable","Component","getUnvisitedNeighbors","node","grid","neighbors","push","length","filter","neighbor","isVisited","dijkstra","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","previousNode","manhattanDistance","Math","abs","findLowerF","currentNode","currentNeighbors","minH","newNode","map","h","console","log","start_node_row","start_node_col","end_node_row","end_node_col","nodeRef","PathfindingVisualizer","buttonText","visualizeAlgorithm","isAnimationRunning","buttonDisabled","endNode","selectedAlgorithm","openList","distanceF","q","Astar","stack","pop","forEach","DFS","priorityQueue","BFS","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animateAlgorithm","handleChange","e","value","target","resetBoard","handleInputChange","name","selectedStartRow","selectedStartCol","selectedEndRow","selectedEndCol","changeStart","newGrid","getNewGridWithNewStart","changeEnd","getNewGridWithNewEnd","ref","setNodeStyle","getInitialGrid","refs","handleMouseUp","isMousePressed","NodesInshortestPathOrder","a","async","i","sleep","setTimeout","animateShortestPath","createref","React","createRef","insertingWalls","insertingWeights","newGridWithWalls","getNewGridWithWalls","newGridWithWeights","getNewGridWithWeights","ms","Promise","resolve","onChange","disabled","onClick","changingStart","htmlFor","type","placeholder","rowIndex","key","nodeIndex","handleMouseDown","handleMouseEnter","currentRow","createNode","slice","oldStart","noLongerStart","newStart","oldEnd","noLongerEnd","newEnd","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"qWAIqBA,G,kBACnB,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KAQRC,eAAiB,SAAAC,GACV,EAAKC,MAAMC,QAAW,EAAKD,MAAME,UACpC,EAAKC,SAAS,CAAEC,YAAaL,KAXd,EAenBM,WAAa,WACX,EAAKF,SAAS,CAAEC,YAAa,GAAIF,UAAU,EAAOD,QAAQ,KAhBzC,EAmBnBK,gBAAkB,SAAAP,GAChB,EAAKI,SAAS,CAAEC,YAAaL,KApBZ,EAuBnBQ,QAAU,WACR,EAAKJ,SAAS,CAAEF,QAAQ,IACxB,EAAKJ,MAAL,eAAkB,EAAKA,MAAvB,CAA8BI,QAAQ,KAzBrB,EA4BnBO,UAAY,WACV,EAAKL,SAAS,CAAED,UAAU,IAC1B,EAAKL,MAAL,eAAkB,EAAKA,MAAvB,CAA8BK,UAAU,KA5BxC,EAAKF,MAAQ,CACXI,YAAa,GACbH,QAAQ,EACRC,UAAU,GALK,E,sEAiCT,IAAD,EASHO,KAAKZ,MAPPa,EAFK,EAELA,IACAC,EAHK,EAGLA,IACAC,EAJK,EAILA,MACAC,EALK,EAKLA,QACAC,EANK,EAMLA,YACAC,EAPK,EAOLA,aACAC,EARK,EAQLA,UAEIC,EAAiBL,EAAQ,cAAgBC,EAAU,aAAe,GAExE,OACE,yBACEK,GAAE,eAAUR,EAAV,YAAiBC,GACnBQ,UAAS,eAAUF,EAAV,YAA4BR,KAAKT,MAAMI,YAAvC,KACTU,YAAa,kBAAMA,EAAYJ,EAAKC,IACpCK,UAAW,kBAAMA,KACjBD,aAAc,kBAAMA,EAAaL,EAAKC,IACtCS,aAAWP,IAAWD,IAAe,W,GArDXS,c,MCJnB,SAASC,EAAsBC,EAAMC,GAClD,IAAMC,EAAY,GACVd,EAAaY,EAAbZ,IAAKD,EAAQa,EAARb,IAKb,OAJIA,EAAM,GAAGe,EAAUC,KAAKF,EAAKd,EAAM,GAAGC,IACtCD,EAAMc,EAAKG,OAAS,GAAGF,EAAUC,KAAKF,EAAKd,EAAM,GAAGC,IACpDA,EAAM,GAAGc,EAAUC,KAAKF,EAAKd,GAAKC,EAAM,IACxCA,EAAMa,EAAK,GAAGG,OAAS,GAAGF,EAAUC,KAAKF,EAAKd,GAAKC,EAAM,IACtDc,EAAUG,QAAO,SAAAC,GAAQ,OAAKA,EAASC,aCLzC,SAASC,EAASP,EAAMQ,EAAWC,GACxC,IAAMC,EAAsB,GAC5BF,EAAUG,SAAW,EAErB,IADA,IAAMC,EA8BR,SAAqBZ,GACnB,IAAMa,EAAQ,GADW,uBAEzB,YAAkBb,EAAlB,+CAAwB,CAAC,IAAdd,EAAa,+BACtB,YAAmBA,EAAnB,+CAAwB,CAAC,IAAda,EAAa,QACtBc,EAAMX,KAAKH,IAFS,oFAFC,kFAOzB,OAAOc,EArCgBC,CAAYd,GAC1BY,EAAeT,QAAQ,CAC9BY,EAAoBH,GACpB,IAAMI,EAAcJ,EAAeK,QACnC,IAAID,EAAYvC,OAAhB,CACA,GAAIuC,EAAYL,WAAaO,IAAU,OAAOR,EAG9C,GAFAM,EAAYV,WAAY,EACxBI,EAAoBR,KAAKc,GACrBA,IAAgBP,EAAY,OAAOC,EACvCS,EAAyBH,EAAahB,KAI1C,SAASe,EAAoBH,GAC3BA,EAAeQ,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMV,SAAWW,EAAMX,YAG/D,SAASQ,EAAyBpB,EAAMC,GACtC,IAAMuB,EAAqBzB,EAAsBC,EAAMC,GADX,uBAE5C,YAAuBuB,EAAvB,+CAA2C,CAAC,IAAjClB,EAAgC,QACrCA,EAAS3B,SACX2B,EAASM,SAAWZ,EAAKY,SAAW,GAEpCN,EAASM,SAAWZ,EAAKY,SAAW,EAGtCN,EAASmB,aAAezB,GATkB,mFCS9C,IAAM0B,EAAoB,SAAC1B,EAAMU,GAa/B,OAXIV,EAAKrB,SAEL,GACAgD,KAAKC,IAAI5B,EAAKb,IAAMuB,EAAWvB,KAC/BwC,KAAKC,IAAI5B,EAAKZ,IAAMsB,EAAWtB,KACxBY,EAAKtB,OACHyC,IAGTQ,KAAKC,IAAI5B,EAAKb,IAAMuB,EAAWvB,KAAOwC,KAAKC,IAAI5B,EAAKZ,IAAMsB,EAAWtB,MAKrEyC,EAAa,SAACC,EAAaC,GAC/B,IAAIC,EAAO,IACPC,EAAU,KASd,OARAF,EAAiBG,KAAI,SAAAlC,GACfA,EAAKmC,EAAIH,IAAShC,EAAKO,YACzByB,EAAOhC,EAAKmC,GACZF,EAAUjC,GACFyB,aAAeK,MAG3BM,QAAQC,IAAIJ,GACLA,GChDT,IAAIK,EAAiB,GACjBC,EAAiB,GACjBC,EAAe,GACfC,EAAe,GACbC,EAAU,GAEKC,E,YACnB,aAAe,IAAD,8BACZ,+CAqBFC,WAAa,WAtBC,EAuBdC,mBAAqB,WACnB,EAAKjE,SAAL,eACK,EAAKH,MADV,CAEEqE,oBAAoB,EACpBC,gBAAgB,KAJO,IAMjB9C,EAAS,EAAKxB,MAAdwB,KACFQ,EAAYR,EAAKqC,GAAgBC,GACjCS,EAAU/C,EAAKuC,GAAcC,GAC/B9B,EAAsB,GAC1B,OAAQ,EAAKlC,MAAMwE,mBACjB,IAAK,WACHtC,EAAsBH,EAASP,EAAMQ,EAAWuC,GAChD,EAAKJ,WAAa,WAClB,MACF,IAAK,QACHjC,EDtDO,SAAeV,EAAMQ,EAAWC,GAC7C,IAAMC,EAAsB,GACtBuC,EAAW,CAACzC,GACZ0C,EAAY,GAUlB,IATA1C,EAAUG,SAAW,EACrBH,EAAU0B,EAAI,EACdlC,EAAKiC,KAAI,SAAA/C,GACPA,EAAI+C,KAAI,SAAAlC,GACNA,EAAKmC,EAAIT,EAAkB1B,EAAMU,GACjCyC,EAAUhD,KAAK,CAACH,EAAKmC,UAIE,IAApBe,EAAS9C,QAAc,CAC5B,IAAI0B,EAAcoB,EAAShC,QAC3BP,EAAoBR,KAAK2B,GACzBA,EAAYvB,WAAY,EACxB,IAAIwB,EAAmBhC,EAAsB+B,EAAa7B,GAEtDmD,EAAIvB,EAAWC,EAAaC,GAChC,GAAU,OAANqB,EACF,OAAOzC,EACF,GAAY,IAARyC,EAAEjB,EACX,OAAOxB,EAEPuC,EAAS/C,KAAKiD,IC6BUC,CAAMpD,EAAMQ,EAAWuC,GAC7C,EAAKJ,WAAa,KAClB,MACF,IAAK,MACHjC,EC1DO,SACbV,EACAQ,EACAC,GAIA,IADC,IAFDC,EAEA,uDAFsB,GACtB2C,EACA,uDADQ,CAAC7C,GACT,aAEE,IAAIqB,EAAcwB,EAAMC,MACxBzB,EAAYvB,WAAY,EACxBI,EAAoBR,KAAK2B,GACzB,IAAIC,EAAmBhC,EAAsB+B,EAAa7B,GAC1D,OAAI6B,IAAgBpB,EACZ,CAAN,EAAOC,IAEToB,EAAiByB,SAAQ,SAAAxD,GAClBA,EAAKtB,SACRsB,EAAKyB,aAAeK,EACpBwB,EAAMnD,KAAKH,OAGM,IAAjBsD,EAAMlD,OACF,CAAN,EAAOO,QADT,IAdsB,IAAjB2C,EAAMlD,QAAc,CAAC,IAAD,yCDmDCqD,CAAIxD,EAAMQ,EAAWuC,GAC3C,EAAKJ,WAAa,MAClB,MACF,IAAK,MACHjC,EE9DO,SAAaV,EAAMQ,EAAWC,GAC3C,IAAMC,EAAsB,GACtB+C,EAAgB,CAACjD,GACvBA,EAAUG,SAAW,EACrBH,EAAU0B,EAAI,EAEd,IANuD,iBAOrD,IAAIL,EAAc4B,EAAcxC,QAChCY,EAAYvB,WAAY,EACxBI,EAAoBR,KAAK2B,GACzB,IAAIC,EAAmBhC,EAAsB+B,EAAa7B,GAC1D,OAAI6B,IAAgBpB,EACZ,CAAN,EAAOC,IAEPoB,EAAiByB,SAAQ,SAAAxD,GAClBA,EAAKtB,SACRsB,EAAKO,WAAY,EACjBP,EAAKyB,aAAeK,EACpB4B,EAAcvD,KAAKH,OAII,IAAzB0D,EAActD,OACV,CAAN,EAAOO,QADT,IAhBK+C,EAActD,OAAS,IAAI,CAAC,IAAD,yCFwDNuD,CAAI1D,EAAMQ,EAAWuC,GAC3C,EAAKJ,WAAa,MAClB,MACF,QACEjC,EAAsBH,EAASP,EAAMQ,EAAWuC,GAChD,EAAKJ,WAAa,WAGtB,IAAMgB,EGxEK,SAAqClD,GAGlD,IAFA,IAAMkD,EAA2B,GAC7B9B,EAAcpB,EACK,OAAhBoB,GACL8B,EAAyBC,QAAQ/B,GACjCA,EAAcA,EAAYL,aAE5B,OAAOmC,EHiE4BE,CAA4Bd,GAC7D,EAAKe,iBAAiBpD,EAAqBiD,IAxD/B,EA2DdI,aAAe,SAAAC,GAAM,IACbC,EAAUD,EAAEE,OAAZD,MAGN,OAFA,EAAKE,aACL,EAAKxF,SAAS,CAAEqE,kBAAmBiB,IAC3BA,GACN,IAAK,WACH,EAAKtB,WAAa,WAClB,EAAKhE,SAAS,CAAEmE,gBAAgB,IAChC,MACF,IAAK,QACH,EAAKH,WAAa,KAClB,EAAKhE,SAAS,CAAEmE,gBAAgB,IAChC,MACF,IAAK,MACH,EAAKH,WAAa,MAClB,EAAKhE,SAAS,CAAEmE,gBAAgB,IAChC,MACF,IAAK,MACH,EAAKH,WAAa,MAClB,EAAKhE,SAAS,CAAEmE,gBAAgB,IAChC,MACF,QACE,EAAKH,WAAa,WAClB,EAAKhE,SAAS,CAAEmE,gBAAgB,MAlFxB,EAuFdsB,kBAAoB,SAAAJ,GAAM,IAClBC,EAAUD,EAAEE,OAAZD,MACN,OAAQD,EAAEE,OAAOG,MACf,IAAK,WACH,EAAK1F,SAAS,CAAE2F,iBAAkBL,IAClC,MACF,IAAK,WACH,EAAKtF,SAAS,CAAE4F,iBAAkBN,IAClC,MACF,IAAK,SACH,EAAKtF,SAAS,CAAE6F,eAAgBP,IAChC,MACF,IAAK,SACH,EAAKtF,SAAS,CAAE8F,eAAgBR,IAChC,MACF,QACE,SAvGQ,EA2GdS,YAAc,WACZ,IAAMC,EAAUC,EACd,EAAKpG,MAAMwB,KACX,EAAKxB,MAAM8F,iBACX,EAAK9F,MAAM+F,kBAEb,EAAK5F,SAAS,CAAEqB,KAAM2E,KAjHV,EAoHdE,UAAY,WACV,IAAMF,EAAUG,EACd,EAAKtG,MAAMwB,KACX,EAAKxB,MAAMgG,eACX,EAAKhG,MAAMiG,gBAEb,EAAK9F,SAAS,CAAEqB,KAAM2E,KA1HV,EAsKd3F,UAAY,SAAC+F,EAAKxG,GAChB,EAAKyG,aAAaD,EAAKxG,GACvBwG,EAAI/F,aAxKQ,EA2KdD,QAAU,SAACgG,EAAKxG,GACd,EAAKyG,aAAaD,EAAKxG,GACvBwG,EAAIhG,WA7KQ,EAgLdF,WAAa,SAAAkG,GACXA,EAAIlG,cAjLQ,EAoLdsF,WAAa,WACX,IAAMQ,EAAUM,IAEhB,IAAK,IAAIxC,KADT,EAAK9D,SAAL,eAAmB,EAAKH,MAAxB,CAA+BwB,KAAM2E,KACjB,EAAKO,KACvB,EAAKrG,WAAW,EAAKqG,KAAL,UAAazC,MAxLnB,EA4Ld0C,cAAgB,WACV,EAAK3G,MAAMqE,oBACf,EAAKlE,SAAS,CAAEyG,gBAAgB,KA9LpB,EAiMdtB,iBAAmB,SAAOpD,EAAqB2E,GAA5B,mBAAAC,EAAAC,OAAA,2DACRC,GADQ,SAAAF,EAAAC,OAAA,mDAEXC,IAAM9E,EAAoBP,OAAS,EAFxB,kCAAAmF,EAAA,MAGP,EAAKG,MAAM,MAHJ,cAIbC,YAAW,WACT,EAAKC,oBAAoBN,KACxB,GAAKG,GANK,qCASfE,YAAW,WACT,IAAI3F,EAAOW,EAAoB8E,GAE/B,EAAKR,aAAa,EAAKE,KAAL,UAAanF,EAAKb,IAAlB,YAAyBa,EAAKZ,MAAQ,kBACvD,GAAKqG,GAbO,sCACRA,EAAI,EADI,YACDA,EAAI9E,EAAoBP,QADvB,mCAAAmF,EAAA,QACRE,IADQ,2FAC+BA,IAD/B,sDAjML,EAkNdR,aAAe,SAACD,EAAKxG,GACnBwG,EAAIzG,eAAeC,IAnNP,EAsNdO,gBAAkB,SAACiG,EAAKxG,GACtBwG,EAAIjG,gBAAgBP,IAvNR,EAuOdqH,UAAY,SAAC1G,EAAKC,GAChB,OAAQsD,EAAQvD,GAAKC,GAAO0G,IAAMC,aAtOlC,EAAKtH,MAAQ,CACXwB,KAAM,GACNoF,gBAAgB,EAChBvC,oBAAoB,EACpBkD,gBAAgB,EAChBC,kBAAkB,EAClBlD,gBAAgB,EAChBE,kBAAmB,WACnBsB,iBAAkBjC,EAClBkC,iBAAkBjC,EAClBkC,eAAgBjC,EAChBkC,eAAgBjC,GAbN,E,iFAkBZ,IAAMxC,EAAOiF,IACbhG,KAAKN,SAAS,CAAEqB,W,sCA0GFd,EAAKC,GACnB,IAAIF,KAAKT,MAAMqE,qBAEb5D,KAAKiG,KAAL,UAAahG,EAAb,YAAoBC,IAAOd,MAAMgB,UACjCJ,KAAKiG,KAAL,UAAahG,EAAb,YAAoBC,IAAOd,MAAMe,MAG5B,GAAIH,KAAKT,MAAMuH,eAAgB,CACpC9G,KAAKF,QAAQE,KAAKiG,KAAL,UAAahG,EAAb,YAAoBC,IAAQ,YAAaD,EAAKC,GAC3D,IAAM8G,EAAmBC,EAAoBjH,KAAKT,MAAMwB,KAAMd,EAAKC,GACnEF,KAAKN,SAAS,CAAEqB,KAAMiG,EAAkBb,gBAAgB,SACnD,GAAInG,KAAKT,MAAMwH,iBAAkB,CACtC/G,KAAKD,UAAUC,KAAKiG,KAAL,UAAahG,EAAb,YAAoBC,IAAQ,cAAeD,EAAKC,GAC/D,IAAMgH,EAAqBC,EACzBnH,KAAKT,MAAMwB,KACXd,EACAC,GAEFF,KAAKN,SAAS,CAAEqB,KAAMmG,EAAoBf,gBAAgB,O,uCAI7ClG,EAAKC,GACpB,GAAKF,KAAKT,MAAM4G,iBACZnG,KAAKT,MAAMqE,mBAEf,GAAI5D,KAAKT,MAAMuH,eAAgB,CAC7B9G,KAAKF,QAAQE,KAAKiG,KAAL,UAAahG,EAAb,YAAoBC,IAAQ,YAAaD,EAAKC,GAC3D,IAAMwF,EAAUuB,EAAoBjH,KAAKT,MAAMwB,KAAMd,EAAKC,GAC1DF,KAAKN,SAAS,CAAEqB,KAAM2E,SACjB,GAAI1F,KAAKT,MAAMwH,iBAAkB,CACtC/G,KAAKD,UAAUC,KAAKiG,KAAL,UAAahG,EAAb,YAAoBC,IAAQ,cAAeD,EAAKC,GAC/D,IAAMgH,EAAqBC,EACzBnH,KAAKT,MAAMwB,KACXd,EACAC,GAEFF,KAAKN,SAAS,CAAEqB,KAAMmG,O,0CAwDNxC,GAClB,IAD6C,IAAD,kBACnC6B,GACPE,YAAW,WACT,IAAM3F,EAAO4D,EAAyB6B,GACtC,EAAK1G,gBACH,EAAKoG,KAAL,UAAanF,EAAKb,IAAlB,YAAyBa,EAAKZ,MAC9B,wBAED,GAAKqG,GACR,EAAK7G,SAAS,CAAEkE,oBAAoB,EAAOC,gBAAgB,KARpD0C,EAAI,EAAGA,EAAI7B,EAAyBxD,OAAQqF,IAAM,EAAlDA,K,4BAgBLa,GACJ,OAAO,IAAIC,SAAQ,SAAAC,GAAO,OAAIb,WAAWa,EAASF,Q,+BAG1C,IAAD,SAC0BpH,KAAKT,MAA9BwB,EADD,EACCA,KAAMoF,EADP,EACOA,eAEd,OACE,6BACE,yBAAKzF,UAAU,QACb,yBAAKA,UAAU,UACb,yBAAKA,UAAU,eACb,yBAAKA,UAAU,mBACb,4BAAQ6G,SAAUvH,KAAK8E,cACrB,4BAAQE,MAAM,YAAd,mCAGA,4BAAQA,MAAM,SAAd,2BACA,4BAAQA,MAAM,OAAd,oBACA,4BAAQA,MAAM,OAAd,qBAEF,4BACEwC,SAAUxH,KAAKT,MAAMqE,mBACrB6D,QAAS,kBAAM,EAAK9D,uBAFtB,aAIa3D,KAAK0D,YAElB,4BACE8D,SAAUxH,KAAKT,MAAMqE,mBACrB6D,QAAS,kBACP,EAAK/H,SAAS,CACZoH,gBAAgB,EAChBC,kBAAkB,EAClBW,eAAe,MANrB,gBAYA,4BACEF,SAAUxH,KAAKT,MAAMsE,eACrB4D,QAAS,kBACP,EAAK/H,SAAS,CACZoH,gBAAgB,EAChBC,kBAAkB,EAClBW,eAAe,MANrB,mBAaF,yBAAKhH,UAAU,mBACb,yBAAKA,UAAU,oBACb,yBAAKA,UAAU,0BACb,yBAAKA,UAAU,mBAAf,eACA,yBAAKA,UAAU,+BAEjB,yBAAKA,UAAU,0BACb,yBAAKA,UAAU,mBAAf,aACA,yBAAKA,UAAU,6BAGjB,yBAAKA,UAAU,0BACb,yBAAKA,UAAU,mBAAf,cACA,yBAAKA,UAAU,8BAEjB,yBAAKA,UAAU,0BACb,yBAAKA,UAAU,mBAAf,gBACA,yBAAKA,UAAU,gCAEjB,4BACEA,UAAU,eACV+G,QAAS,kBAAM,EAAKvC,cACpBsC,SAAUxH,KAAKT,MAAMqE,oBAHvB,kBAUN,yBAAKlD,UAAU,QACb,yBAAKA,UAAU,kBACb,2BAAOiH,QAAQ,YAAf,cACA,2BACElH,GAAG,WACHmH,KAAK,SACLxC,KAAK,WACLyC,YAAazE,EACbmE,SAAUvH,KAAKmF,qBAGnB,yBAAKzE,UAAU,kBACb,2BAAOiH,QAAQ,YAAf,cACA,2BACElH,GAAG,WACHmH,KAAK,SACLxC,KAAK,WACLyC,YAAaxE,EACbkE,SAAUvH,KAAKmF,qBAGnB,4BACEzE,UAAU,eACV+G,QAAS,kBAAM,EAAKhC,eACpB+B,SAAUxH,KAAKT,MAAMqE,oBAHvB,iBAQF,yBAAKlD,UAAU,QACb,yBAAKA,UAAU,kBACb,2BAAOiH,QAAQ,UAAf,YACA,2BACElH,GAAG,SACHmH,KAAK,SACLxC,KAAK,SACLyC,YAAavE,EACbiE,SAAUvH,KAAKmF,qBAGnB,yBAAKzE,UAAU,kBACb,2BAAOiH,QAAQ,YAAf,YACA,2BACElH,GAAG,SACHmH,KAAK,SACLxC,KAAK,SACLyC,YAAatE,EACbgE,SAAUvH,KAAKmF,qBAGnB,4BACEzE,UAAU,eACV8G,SAAUxH,KAAKT,MAAMqE,mBACrB6D,QAAS,kBAAM,EAAK7B,cAHtB,gBASH7E,EAAKiC,KAAI,SAAC/C,EAAK6H,GACd,OACE,yBAAKC,IAAKD,GACP7H,EAAI+C,KAAI,SAAClC,EAAMkH,GAAe,IACrB/H,EAA6Ba,EAA7Bb,IAAKC,EAAwBY,EAAxBZ,IAAKE,EAAmBU,EAAnBV,QAASD,EAAUW,EAAVX,MAE3B,OACE,kBAAC,EAAD,CACE2F,IAAG,UAAK7F,EAAL,YAAYC,GACf6H,IAAKC,EACL5H,QAASA,EACTD,MAAOA,EACPD,IAAKA,EACLD,IAAKA,EACLkG,eAAgBA,EAChB9F,YAAa,SAACJ,EAAKC,GAAN,OAAc,EAAK+H,gBAAgBhI,EAAKC,IACrDI,aAAc,SAACL,EAAKC,GAAN,OACZ,EAAKgI,iBAAiBjI,EAAKC,IAE7BK,UAAW,kBAAM,EAAK2F,gC,GA3YOtF,aAuZ7CoF,EAAiB,WAErB,IADA,IAAMjF,EAAO,GACJd,EAAM,EAAGA,EAAM,GAAIA,IAAO,CAGjC,IAFA,IAAMkI,EAAa,GACbrH,EAAO,GACJZ,EAAM,EAAGA,EAAM,GAAIA,IAC1BiI,EAAWlH,KAAKmH,EAAWlI,EAAKD,IAChCa,EAAKG,KAAK,CAAChB,EAAKC,IAElBa,EAAKE,KAAKkH,GACV3E,EAAQvC,KAAKH,GAEf,OAAOC,GAGHqH,EAAa,SAAClI,EAAKD,GACvB,MAAO,CACLC,MACAD,MACAG,QAASH,IAAQmD,GAAkBlD,IAAQmD,EAC3ClD,MAAOF,IAAQqD,GAAgBpD,IAAQqD,EACvClC,WAAW,EACX7B,QAAQ,EACRkC,SAAUO,IACVM,aAAc,KACd9C,UAAU,EACVwD,EAAG,OAIDgE,EAAsB,SAAClG,EAAMd,EAAKC,GACtC,IAAMwF,EAAU3E,EAAKsH,QACfvH,EAAO4E,EAAQzF,GAAKC,GACpB6C,EAAO,eACRjC,EADQ,CAEXtB,QAASsB,EAAKtB,SAGhB,OADAkG,EAAQzF,GAAKC,GAAO6C,EACb2C,GAGHyB,EAAwB,SAACpG,EAAMd,EAAKC,GACxC,IAAMwF,EAAU3E,EAAKsH,QACfvH,EAAO4E,EAAQzF,GAAKC,GACpB6C,EAAO,eACRjC,EADQ,CAEXrB,UAAWqB,EAAKrB,WAGlB,OADAiG,EAAQzF,GAAKC,GAAO6C,EACb2C,GAGHC,EAAyB,SAAC5E,EAAMd,EAAKC,GACzC,IAAMwF,EAAU3E,EAAKsH,QACfC,EAAW5C,EAAQtC,GAAgBC,GACnCkF,EAAa,eACdD,EADc,CAEjBlI,SAAS,IAEXsF,EAAQtC,GAAgBC,GAAkBkF,EAC1C,IAAMzH,EAAO4E,EAAQzF,GAAKC,GACpBsI,EAAQ,eACT1H,EADS,CAEZV,SAAS,IAKX,OAHAsF,EAAQzF,GAAKC,GAAOsI,EACpBpF,EAAiBnD,EACjBoD,EAAiBnD,EACVwF,GAGHG,EAAuB,SAAC9E,EAAMd,EAAKC,GACvC,IAAMwF,EAAU3E,EAAKsH,QACfI,EAAS/C,EAAQpC,GAAcC,GAC/BmF,EAAW,eACZD,EADY,CAEftI,OAAO,IAETuF,EAAQpC,GAAcC,GAAgBmF,EACtC,IAAM5H,EAAO4E,EAAQzF,GAAKC,GACpByI,EAAM,eACP7H,EADO,CAEVX,OAAO,IAKT,OAHAuF,EAAQzF,GAAKC,GAAOyI,EACpBrF,EAAerD,EACfsD,EAAerD,EACRwF,GIlfMkD,MARf,WACE,OACE,yBAAKlI,UAAU,OACb,kBAAC,EAAD,QCKcmI,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.a51ee899.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      nodeVisited: \"\",\n      isWall: false,\n      isWeight: false\n    };\n  }\n\n  setNodeVisited = string => {\n    if (!this.state.isWall && !this.state.isWeight) {\n      this.setState({ nodeVisited: string });\n    }\n  };\n\n  resetStyle = () => {\n    this.setState({ nodeVisited: \"\", isWeight: false, isWall: false });\n  };\n\n  setShortestPath = string => {\n    this.setState({ nodeVisited: string });\n  };\n\n  setWall = () => {\n    this.setState({ isWall: true });\n    this.props = { ...this.props, isWall: true };\n  };\n\n  setWeight = () => {\n    this.setState({ isWeight: true });\n    this.props = { ...this.props, isWeight: true };\n  };\n\n  render() {\n    const {\n      row,\n      col,\n      isEnd,\n      isStart,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp\n    } = this.props;\n    const extraClassName = isEnd ? \"node-finish\" : isStart ? \"node-start\" : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName} ${this.state.nodeVisited} `}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseUp={() => onMouseUp()}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        draggable={isStart || isEnd ? true : null}\n      ></div>\n    );\n  }\n}\n","export default function getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n","import getUnvisitedNeighbors from \"../helpers/getUnvisitedNeighbors\";\n\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    if (neighbor.isWeight) {\n      neighbor.distance = node.distance + 20;\n    } else {\n      neighbor.distance = node.distance + 1;\n    }\n\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n","import getUnvisitedNeighbors from \"../helpers/getUnvisitedNeighbors\";\n\nexport default function Astar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const openList = [startNode];\n  const distanceF = [];\n  startNode.distance = 0;\n  startNode.h = 0;\n  grid.map(row => {\n    row.map(node => {\n      node.h = manhattanDistance(node, finishNode);\n      distanceF.push([node.h]);\n    });\n  });\n\n  while (openList.length !== 0) {\n    let currentNode = openList.shift();\n    visitedNodesInOrder.push(currentNode);\n    currentNode.isVisited = true;\n    let currentNeighbors = getUnvisitedNeighbors(currentNode, grid);\n\n    let q = findLowerF(currentNode, currentNeighbors);\n    if (q === null) {\n      return visitedNodesInOrder;\n    } else if (q.h === 0) {\n      return visitedNodesInOrder;\n    } else {\n      openList.push(q);\n    }\n  }\n}\nconst manhattanDistance = (node, finishNode) => {\n  let distance = 9999;\n  if (node.isWeight) {\n    distance =\n      30 +\n      Math.abs(node.row - finishNode.row) +\n      Math.abs(node.col - finishNode.col);\n  } else if (node.isWall) {\n    distance = Infinity;\n  } else {\n    distance =\n      Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col);\n  }\n  return distance;\n};\n\nconst findLowerF = (currentNode, currentNeighbors) => {\n  let minH = 999;\n  let newNode = null;\n  currentNeighbors.map(node => {\n    if (node.h < minH && !node.isVisited) {\n      minH = node.h;\n      newNode = node;\n      newNode.previousNode = currentNode;\n    }\n  });\n  console.log(newNode);\n  return newNode;\n};\n","/* eslint-disable no-loop-func */\nimport React, { Component } from 'react';\nimport Node from '../node/node';\nimport './PathfindingVisualizer.css';\nimport { dijkstra } from '../../algorithms/weightedAlgorithms/dijkstra';\nimport getNodesInShortestPathOrder from '../../algorithms/helpers/getNodesInShortestPathOrder';\nimport Astar from '../../algorithms/weightedAlgorithms/Astar';\nimport BFS from '../../algorithms/unweightedAlgorithms/BFS';\nimport DFS from '../../algorithms/unweightedAlgorithms/DFS';\n\nlet start_node_row = 10;\nlet start_node_col = 15;\nlet end_node_row = 10;\nlet end_node_col = 35;\nconst nodeRef = [];\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      isMousePressed: false,\n      isAnimationRunning: false,\n      insertingWalls: true,\n      insertingWeights: false,\n      buttonDisabled: false,\n      selectedAlgorithm: 'dijkstra',\n      selectedStartRow: start_node_row,\n      selectedStartCol: start_node_col,\n      selectedEndRow: end_node_row,\n      selectedEndCol: end_node_col\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  buttonText = 'Dijkstra';\n  visualizeAlgorithm = () => {\n    this.setState({\n      ...this.state,\n      isAnimationRunning: true,\n      buttonDisabled: true\n    });\n    const { grid } = this.state;\n    const startNode = grid[start_node_row][start_node_col];\n    const endNode = grid[end_node_row][end_node_col];\n    let visitedNodesInOrder = [];\n    switch (this.state.selectedAlgorithm) {\n      case 'dijsktra':\n        visitedNodesInOrder = dijkstra(grid, startNode, endNode);\n        this.buttonText = 'Dijsktra';\n        break;\n      case 'aStar':\n        visitedNodesInOrder = Astar(grid, startNode, endNode);\n        this.buttonText = 'A*';\n        break;\n      case 'DFS':\n        visitedNodesInOrder = DFS(grid, startNode, endNode);\n        this.buttonText = 'DFS';\n        break;\n      case 'BFS':\n        visitedNodesInOrder = BFS(grid, startNode, endNode);\n        this.buttonText = 'BFS';\n        break;\n      default:\n        visitedNodesInOrder = dijkstra(grid, startNode, endNode);\n        this.buttonText = 'Dijsktra';\n        break;\n    }\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  handleChange = e => {\n    let { value } = e.target;\n    this.resetBoard();\n    this.setState({ selectedAlgorithm: value });\n    switch (value) {\n      case 'dijsktra':\n        this.buttonText = 'dijsktra';\n        this.setState({ buttonDisabled: false });\n        break;\n      case 'aStar':\n        this.buttonText = 'A*';\n        this.setState({ buttonDisabled: false });\n        break;\n      case 'DFS':\n        this.buttonText = 'DFS';\n        this.setState({ buttonDisabled: true });\n        break;\n      case 'BFS':\n        this.buttonText = 'BFS';\n        this.setState({ buttonDisabled: true });\n        break;\n      default:\n        this.buttonText = 'dijsktra';\n        this.setState({ buttonDisabled: false });\n        break;\n    }\n  };\n\n  handleInputChange = e => {\n    let { value } = e.target;\n    switch (e.target.name) {\n      case 'startRow':\n        this.setState({ selectedStartRow: value });\n        break;\n      case 'startCol':\n        this.setState({ selectedStartCol: value });\n        break;\n      case 'endRow':\n        this.setState({ selectedEndRow: value });\n        break;\n      case 'endCol':\n        this.setState({ selectedEndCol: value });\n        break;\n      default:\n        return;\n    }\n  };\n\n  changeStart = () => {\n    const newGrid = getNewGridWithNewStart(\n      this.state.grid,\n      this.state.selectedStartRow,\n      this.state.selectedStartCol\n    );\n    this.setState({ grid: newGrid });\n  };\n\n  changeEnd = () => {\n    const newGrid = getNewGridWithNewEnd(\n      this.state.grid,\n      this.state.selectedEndRow,\n      this.state.selectedEndCol\n    );\n    this.setState({ grid: newGrid });\n  };\n\n  handleMouseDown(row, col) {\n    if (this.state.isAnimationRunning) return;\n    if (\n      this.refs[`${row}-${col}`].props.isStart ||\n      this.refs[`${row}-${col}`].props.isEnd\n    ) {\n      return;\n    } else if (this.state.insertingWalls) {\n      this.setWall(this.refs[`${row}-${col}`], 'node-wall', row, col);\n      const newGridWithWalls = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({ grid: newGridWithWalls, isMousePressed: true });\n    } else if (this.state.insertingWeights) {\n      this.setWeight(this.refs[`${row}-${col}`], 'node-weight', row, col);\n      const newGridWithWeights = getNewGridWithWeights(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGridWithWeights, isMousePressed: true });\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isMousePressed) return;\n    if (this.state.isAnimationRunning) return;\n\n    if (this.state.insertingWalls) {\n      this.setWall(this.refs[`${row}-${col}`], 'node-wall', row, col);\n      const newGrid = getNewGridWithWalls(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n    } else if (this.state.insertingWeights) {\n      this.setWeight(this.refs[`${row}-${col}`], 'node-weight', row, col);\n      const newGridWithWeights = getNewGridWithWeights(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGridWithWeights });\n    }\n  }\n\n  setWeight = (ref, string) => {\n    this.setNodeStyle(ref, string);\n    ref.setWeight();\n  };\n\n  setWall = (ref, string) => {\n    this.setNodeStyle(ref, string);\n    ref.setWall();\n  };\n\n  resetStyle = ref => {\n    ref.resetStyle();\n  };\n\n  resetBoard = () => {\n    const newGrid = getInitialGrid();\n    this.setState({ ...this.state, grid: newGrid });\n    for (let nodeRef in this.refs) {\n      this.resetStyle(this.refs[`${nodeRef}`]);\n    }\n  };\n\n  handleMouseUp = () => {\n    if (this.state.isAnimationRunning) return;\n    this.setState({ isMousePressed: false });\n  };\n\n  animateAlgorithm = async (visitedNodesInOrder, NodesInshortestPathOrder) => {\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length - 1) {\n        await this.sleep(2000);\n        setTimeout(() => {\n          this.animateShortestPath(NodesInshortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        let node = visitedNodesInOrder[i];\n\n        this.setNodeStyle(this.refs[`${node.row}-${node.col}`], 'node-visited');\n      }, 10 * i);\n    }\n  };\n\n  setNodeStyle = (ref, string) => {\n    ref.setNodeVisited(string);\n  };\n\n  setShortestPath = (ref, string) => {\n    ref.setShortestPath(string);\n  };\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        this.setShortestPath(\n          this.refs[`${node.row}-${node.col}`],\n          'node-shortest-path'\n        );\n      }, 40 * i);\n      this.setState({ isAnimationRunning: false, buttonDisabled: false });\n    }\n  }\n\n  createref = (row, col) => {\n    return (nodeRef[row][col] = React.createRef());\n  };\n\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  render() {\n    const { grid, isMousePressed } = this.state;\n\n    return (\n      <div>\n        <div className=\"grid\">\n          <div className=\"header\">\n            <div className=\"left-header\">\n              <div className=\"left-header-top\">\n                <select onChange={this.handleChange}>\n                  <option value=\"dijsktra\">\n                    Dijkstra's algorithm (Weighted)\n                  </option>\n                  <option value=\"aStar\">A* algorithm (Weighted)</option>\n                  <option value=\"DFS\">DFS (Unweighted)</option>\n                  <option value=\"BFS\">BFS (Unweighted)</option>\n                </select>\n                <button\n                  disabled={this.state.isAnimationRunning}\n                  onClick={() => this.visualizeAlgorithm()}\n                >\n                  Visualize {this.buttonText}\n                </button>\n                <button\n                  disabled={this.state.isAnimationRunning}\n                  onClick={() =>\n                    this.setState({\n                      insertingWalls: true,\n                      insertingWeights: false,\n                      changingStart: false\n                    })\n                  }\n                >\n                  Insert Walls\n                </button>\n                <button\n                  disabled={this.state.buttonDisabled}\n                  onClick={() =>\n                    this.setState({\n                      insertingWalls: false,\n                      insertingWeights: true,\n                      changingStart: false\n                    })\n                  }\n                >\n                  Insert weights\n                </button>\n              </div>\n              <div className=\"left-header-bot\">\n                <div className=\"node-description\">\n                  <div className=\"start-node-description\">\n                    <div className=\"start-node-text\">Start node:</div>\n                    <div className=\"node-logo start-node-logo\"></div>\n                  </div>\n                  <div className=\"start-node-description\">\n                    <div className=\"start-node-text\">End node:</div>\n                    <div className=\"node-logo end-node-logo\"></div>\n                  </div>\n\n                  <div className=\"start-node-description\">\n                    <div className=\"start-node-text\">Wall node:</div>\n                    <div className=\"node-logo wall-node-logo\"></div>\n                  </div>\n                  <div className=\"start-node-description\">\n                    <div className=\"start-node-text\">Weight node:</div>\n                    <div className=\"node-logo weight-node-logo\"></div>\n                  </div>\n                  <button\n                    className=\"small-button\"\n                    onClick={() => this.resetBoard()}\n                    disabled={this.state.isAnimationRunning}\n                  >\n                    Reset Board\n                  </button>\n                </div>\n              </div>\n            </div>\n            <div className=\"Form\">\n              <div className=\"inputContainer\">\n                <label htmlFor=\"startRow\">Start row:</label>\n                <input\n                  id=\"startRow\"\n                  type=\"number\"\n                  name=\"startRow\"\n                  placeholder={start_node_row}\n                  onChange={this.handleInputChange}\n                />\n              </div>\n              <div className=\"inputContainer\">\n                <label htmlFor=\"startCol\">Start col:</label>\n                <input\n                  id=\"startCol\"\n                  type=\"number\"\n                  name=\"startCol\"\n                  placeholder={start_node_col}\n                  onChange={this.handleInputChange}\n                />\n              </div>\n              <button\n                className=\"small-button\"\n                onClick={() => this.changeStart()}\n                disabled={this.state.isAnimationRunning}\n              >\n                Change Start\n              </button>\n            </div>\n            <div className=\"Form\">\n              <div className=\"inputContainer\">\n                <label htmlFor=\"endRow\">End row:</label>\n                <input\n                  id=\"endRow\"\n                  type=\"number\"\n                  name=\"endRow\"\n                  placeholder={end_node_row}\n                  onChange={this.handleInputChange}\n                />\n              </div>\n              <div className=\"inputContainer\">\n                <label htmlFor=\"startCol\">End col:</label>\n                <input\n                  id=\"endCol\"\n                  type=\"number\"\n                  name=\"endCol\"\n                  placeholder={end_node_col}\n                  onChange={this.handleInputChange}\n                />\n              </div>\n              <button\n                className=\"small-button\"\n                disabled={this.state.isAnimationRunning}\n                onClick={() => this.changeEnd()}\n              >\n                Change end\n              </button>\n            </div>\n          </div>\n          {grid.map((row, rowIndex) => {\n            return (\n              <div key={rowIndex}>\n                {row.map((node, nodeIndex) => {\n                  const { row, col, isStart, isEnd } = node;\n\n                  return (\n                    <Node\n                      ref={`${row}-${col}`}\n                      key={nodeIndex}\n                      isStart={isStart}\n                      isEnd={isEnd}\n                      col={col}\n                      row={row}\n                      isMousePressed={isMousePressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                    />\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    const node = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n      node.push([row, col]);\n    }\n    grid.push(currentRow);\n    nodeRef.push(node);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === start_node_row && col === start_node_col,\n    isEnd: row === end_node_row && col === end_node_col,\n    isVisited: false,\n    isWall: false,\n    distance: Infinity,\n    previousNode: null,\n    isWeight: false,\n    h: null\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithWeights = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWeight: !node.isWeight\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithNewStart = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const oldStart = newGrid[start_node_row][start_node_col];\n  const noLongerStart = {\n    ...oldStart,\n    isStart: false\n  };\n  newGrid[start_node_row][start_node_col] = noLongerStart;\n  const node = newGrid[row][col];\n  const newStart = {\n    ...node,\n    isStart: true\n  };\n  newGrid[row][col] = newStart;\n  start_node_row = row;\n  start_node_col = col;\n  return newGrid;\n};\n\nconst getNewGridWithNewEnd = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const oldEnd = newGrid[end_node_row][end_node_col];\n  const noLongerEnd = {\n    ...oldEnd,\n    isEnd: false\n  };\n  newGrid[end_node_row][end_node_col] = noLongerEnd;\n  const node = newGrid[row][col];\n  const newEnd = {\n    ...node,\n    isEnd: true\n  };\n  newGrid[row][col] = newEnd;\n  end_node_row = row;\n  end_node_col = col;\n  return newGrid;\n};\n","import getUnvisitedNeighbors from \"../helpers/getUnvisitedNeighbors\";\n\nexport default function DFS(\n  grid,\n  startNode,\n  finishNode,\n  visitedNodesInOrder = [],\n  stack = [startNode]\n) {\n  while (stack.length !== 0) {\n    let currentNode = stack.pop();\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n    let currentNeighbors = getUnvisitedNeighbors(currentNode, grid);\n    if (currentNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n    currentNeighbors.forEach(node => {\n      if (!node.isWall) {\n        node.previousNode = currentNode;\n        stack.push(node);\n      }\n    });\n    if (stack.length === 0) {\n      return visitedNodesInOrder;\n    }\n  }\n}\n","import getUnvisitedNeighbors from \"../helpers/getUnvisitedNeighbors\";\n\nexport default function BFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const priorityQueue = [startNode];\n  startNode.distance = 0;\n  startNode.h = 0;\n\n  while (priorityQueue.length < 50) {\n    let currentNode = priorityQueue.shift();\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n    let currentNeighbors = getUnvisitedNeighbors(currentNode, grid);\n    if (currentNode === finishNode) {\n      return visitedNodesInOrder;\n    } else {\n      currentNeighbors.forEach(node => {\n        if (!node.isWall) {\n          node.isVisited = true;\n          node.previousNode = currentNode;\n          priorityQueue.push(node);\n        }\n      });\n    }\n    if (priorityQueue.length === 0) {\n      return visitedNodesInOrder;\n    }\n  }\n}\n","export default function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfidingVisualizer from \"./components/pathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfidingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}